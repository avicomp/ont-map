# baseURI: http://spinrdf.org/spl
# imports: http://spinrdf.org/spin
# prefix: spl

@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

arg:class
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:instance
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:max
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxCount
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxLength
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:min
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:minCount
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:minLength
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:otherProperty
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:pattern
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:property
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:type
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:uriStart
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
sp:UUID
  rdf:type spin:Function ;
  spin:returnType rdfs:Resource ;
  spin:symbol "UUID" ;
  rdfs:comment "Returns a fresh IRI from the UUID URN scheme. Each call of UUID() returns a different UUID. It must not be the \"nil\" UUID (all zeroes). The variant and version of the UUID is implementation dependent." ;
  rdfs:label "UUID" ;
  rdfs:subClassOf spl:URIFunctions ;
.
sp:abs
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input value." ;
    ] ;
  spin:symbol "abs" ;
  rdfs:comment "Returns the absolute value of arg. An error is raised if arg is not a numeric value." ;
  rdfs:label "abs" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-abs> ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:add
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the first number" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the second number" ;
    ] ;
  spin:symbol "+" ;
  rdfs:comment "Returns the arithmetic sum of its operands." ;
  rdfs:label "add" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:and
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the first operand of the intersection" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the second operand of the intersection" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "&&" ;
  rdfs:comment "Return the logical AND between two (boolean) operands." ;
  rdfs:label "and" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:bnode
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sp:arg1 ;
      rdfs:comment "A literal input node." ;
    ] ;
  spin:symbol "BNODE" ;
  rdfs:comment "Constructs a blank node that is distinct from all blank nodes in the dataset being queried and distinct from all blank nodes created by calls to this constructor for other query solutions. If the no argument form is used, every call results in a distinct blank node. If the form with a simple literal is used, every call results in distinct blank nodes for different simple literals, and the same blank node for calls with the same simple literal within expressions for one solution mapping. This functionality is compatible with the treatment of blank nodes in SPARQL CONSTRUCT templates." ;
  rdfs:label "bnode" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-bnode> ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
sp:bound
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the variable or expression that is checked" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "bound" ;
  rdfs:comment "Returns true if ?arg1 is bound to a value. Returns false otherwise. Variables with the value NaN or INF are considered bound." ;
  rdfs:label "bound" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:ceil
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The number to get the ceiling of." ;
    ] ;
  spin:symbol "ceil" ;
  rdfs:comment "Returns the smallest (closest to negative infinity) number with no fractional part that is not less than the value of arg. An error is raised if ?arg1 is not a numeric value." ;
  rdfs:label "ceil" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-ceil> ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:coalesce
  rdf:type spin:Function ;
  spin:symbol "COALESCE" ;
  rdfs:comment "Takes any number of arguments, and returns the first bound argument, starting at the left." ;
  rdfs:label "COALESCE" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:concat
  rdf:type spin:Function ;
  spin:returnType xsd:string ;
  spin:symbol "CONCAT" ;
  rdfs:comment "The CONCAT built-in function. Creates a single string by concatenating all arguments from left to right. Note that if any one of the arguments is unbound (null) then the whole result string will be unbound." ;
  rdfs:label "concat" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:contains
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The sub-string to search for in the input string." ;
    ] ;
  spin:symbol "CONTAINS" ;
  rdfs:comment "Returns an xsd:boolean indicating whether or not the value of ?arg1 contains (at the beginning, at the end, or anywhere within) at least one sequence of collation units that provides a minimal match to the collation units in the value of ?arg2, according to the collation that is used." ;
  rdfs:label "contains" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-contains> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:datatype
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the literal to get the datatype of" ;
    ] ;
  spin:returnType rdfs:Class ;
  spin:symbol "datatype" ;
  rdfs:comment "Returns the datatype IRI of argument ?arg1; returns xsd:string if the parameter is a simple literal." ;
  rdfs:label "datatype" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
sp:day
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The date or dateTime argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "day" ;
  rdfs:comment "Extracts the day from a date/time literal." ;
  rdfs:label "day" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:divide
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType rdfs:Literal ;
  spin:symbol "/" ;
  rdfs:comment "Returns the arithmetic quotient of its operands." ;
  rdfs:label "divide" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:encode_for_uri
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to convert." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "ENCODE_FOR_URI" ;
  rdfs:label "encode_for_uri" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:eq
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the first value to compare" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the second value to compare" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "=" ;
  rdfs:comment "Returns true if both arguments are equal." ;
  rdfs:label "eq" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:exists
  rdf:type spin:Function ;
  spin:returnType xsd:boolean ;
  spin:symbol "EXISTS" ;
  rdfs:comment "The filter function EXISTS. The graph pattern is stored in sp:elements." ;
  rdfs:label "EXISTS" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:floor
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The value to get the floor of." ;
    ] ;
  spin:symbol "floor" ;
  rdfs:comment "Returns the largest (closest to positive infinity) number with no fractional part that is not greater than the value of ?arg1. An error is raised if ?arg1 is not a numeric value." ;
  rdfs:label "floor" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-floor> ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:ge
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol ">=" ;
  rdfs:comment "Returns true if ?arg1 >= ?arg2." ;
  rdfs:label "ge" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:gt
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol ">" ;
  rdfs:comment "Returns true if ?arg1 > arg2." ;
  rdfs:label "gt" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:hours
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The dateTime or time argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "hours" ;
  rdfs:comment "Extracts the hours from a date/time literal." ;
  rdfs:label "hours" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:if
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "A condition to evaluate - if true then the ?arg2 will be returned, otherwise ?arg3." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The function result if ?arg1 is true." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The function result if ?arg1 is false." ;
    ] ;
  spin:symbol "IF" ;
  rdfs:comment "The SPARQL 1.1 built-in function IF." ;
  rdfs:label "IF" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:in
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The value to find." ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "IN" ;
  rdfs:comment "Checks whether the value on the left (?arg1) is one of the values on the right (?arg2, ?arg3 ...)." ;
  rdfs:label "IN" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:iri
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The IRI string to convert to a resource." ;
    ] ;
  spin:returnType rdfs:Resource ;
  spin:symbol "IRI" ;
  rdfs:comment "Creates a IRI resource (node) from a given IRI string (?arg1)." ;
  rdfs:label "IRI" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
sp:isBlank
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node being checked" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "isBlank" ;
  rdfs:comment "Checks whether a given node is a blank node." ;
  rdfs:label "isBlank" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:isIRI
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node being tested" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "isIRI" ;
  rdfs:comment "Checks whether a given node is a IRI node." ;
  rdfs:label "isIRI" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:isLiteral
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node being tested" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "isLiteral" ;
  rdfs:comment "Checks whether a given node is a literal." ;
  rdfs:label "isLiteral" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:isNumeric
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment """The node to check whether it's numeric.
""" ;
    ] ;
  spin:symbol "isNumeric" ;
  rdfs:comment "Returns true if arg1 is a numeric value. Returns false otherwise. term is numeric if it has an appropriate datatype (see the section Operand Data Types) and has a valid lexical form, making it a valid argument to functions and operators taking numeric arguments." ;
  rdfs:label "is numeric" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-isNumeric> ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:isURI
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node to check" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "isURI" ;
  rdfs:comment "Checks whether a node is a URI." ;
  rdfs:label "isURI" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:lang
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the literal to get the language of" ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "lang" ;
  rdfs:comment "Returns the language tag of ?arg1, if it has one. It returns \"\" if the literal has no language tag. Node that the RDF data model does not include literals with an empty language tag." ;
  rdfs:label "lang" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:langMatches
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the literal that is expected to have ?arg2 as language tag" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the language tag that ?arg1 must have" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "langMatches" ;
  rdfs:comment "Returns true if language-tag (first argument) matches language-range (second argument) per the basic filtering scheme defined in [RFC4647] section 3.3.1." ;
  rdfs:label "langMatches" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:lcase
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "LCASE" ;
  rdfs:comment "Converts a string to lower case characters." ;
  rdfs:label "LCASE" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-lcase> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:le
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "<=" ;
  rdfs:comment "Returns true if ?arg1 <= ?arg2." ;
  rdfs:label "le" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:lt
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "<" ;
  rdfs:comment "Returns true if ?arg1 < ?arg2." ;
  rdfs:label "lt" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:md5
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input literal." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "MD5" ;
  rdfs:comment "Returns the MD5 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the xsd:string. Hex digits SHOULD be in lower case." ;
  rdfs:label "md5" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-md5> ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:minutes
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The dateTime or time argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "minutes" ;
  rdfs:comment "Extracts the minutes from a date/time literal." ;
  rdfs:label "minutes" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:month
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The date or dateTime argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "month" ;
  rdfs:comment "Extracts the month from a date/time literal." ;
  rdfs:label "month" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:mul
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:symbol "*" ;
  rdfs:comment "Returns the arithmetic product of its operands." ;
  rdfs:label "mul" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:ne
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "!=" ;
  rdfs:comment "Returns true if ?arg1 != ?arg2." ;
  rdfs:label "ne" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:not
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the operand to negate" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "!" ;
  rdfs:comment "Returns the boolean negation of the argument." ;
  rdfs:label "not" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:notExists
  rdf:type spin:Function ;
  spin:returnType xsd:boolean ;
  spin:symbol "NOT EXISTS" ;
  rdfs:comment "The filter function NOT EXISTS. The graph pattern is stored in sp:elements." ;
  rdfs:label "NOT EXISTS" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:notIn
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The value to find." ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "NOT IN" ;
  rdfs:comment "Checks whether the value on the left (?arg1) is none of the values on the right (?arg2, ?arg3 ...)." ;
  rdfs:label "NOT IN" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:now
  rdf:type spin:Function ;
  spin:returnType xsd:dateTime ;
  spin:symbol "now" ;
  rdfs:comment "Gets the current date and time as an xsd:dateTime literal." ;
  rdfs:label "now" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:or
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "||" ;
  rdfs:comment "Returns the logical OR between two (boolean) operands." ;
  rdfs:label "or" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:rand
  rdf:type spin:Function ;
  spin:returnType xsd:double ;
  spin:symbol "RAND" ;
  rdfs:comment "Returns a number between 0 (inclusive) and 1.0e0 (exclusive). Different numbers can be produced every time this function is invoked. Numbers should be produced with approximately equal probability." ;
  rdfs:label "rand" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#idp3722352> ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:regex
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "the flags" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the match pattern" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "regex" ;
  rdfs:comment "Returns true if a string (?arg1) matches the regular expression supplied as a pattern (?arg2) as influenced by the value of flags (?arg3), otherwise returns false." ;
  rdfs:label "regex" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-regex> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:replace
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sp:arg4 ;
      spl:valueType xsd:string ;
      rdfs:comment "Additional flags for the replacement." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment """The pattern to replace.
""" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "The replacement string." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "REPLACE" ;
  rdfs:comment "Replaces each non-overlapping occurrence of a regular expression pattern with a replacement string. Regular expession matching may involve modifier flags." ;
  rdfs:label "replace" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-replace> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:round
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The number to round." ;
    ] ;
  spin:symbol "round" ;
  rdfs:comment "Returns the number with no fractional part that is closest to the argument. If there are two such numbers, then the one that is closest to positive infinity is returned. An error is raised if ?arg1 is not a numeric value." ;
  rdfs:label "round" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-round> ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:sameTerm
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the first argument" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "the second argument" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "sameTerm" ;
  rdfs:comment "Returns TRUE if ?arg1 and ?arg2 are the same RDF term as defined in Resource Description Framework (RDF): Concepts and Abstract Syntax; returns FALSE otherwise." ;
  rdfs:label "same term" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-sameTerm> ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:seconds
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The dateTime or time argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "seconds" ;
  rdfs:comment "Extracts the seconds from a date/time literal." ;
  rdfs:label "seconds" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:sha1
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input literal." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "SHA1" ;
  rdfs:comment "Returns the SHA1 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the xsd:string. Hex digits SHOULD be in lower case." ;
  rdfs:label "sha1" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-sha1> ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:sha256
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input literal." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "SHA256" ;
  rdfs:comment "Returns the SHA256 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the xsd:string. Hex digits SHOULD be in lower case." ;
  rdfs:label "sha256" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-sha256> ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:sha384
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input literal." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "SHA384" ;
  rdfs:comment "Returns the SHA384 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the xsd:string. Hex digits SHOULD be in lower case." ;
  rdfs:label "sha384" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-sha384> ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:sha512
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input literal." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "SHA512" ;
  rdfs:comment "Returns the SHA512 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the xsd:string. Hex digits SHOULD be in lower case." ;
  rdfs:label "sha512" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-sha512> ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:str
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node to convert to string" ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "str" ;
  rdfs:comment "Returns the lexical form of ?arg1 (a literal); returns the codepoint representation of ?arg1 (an IRI). This is useful for examining parts of an IRI, for instance, the host-name." ;
  rdfs:label "str" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strafter
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The pattern to find within the input string." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "STRAFTER" ;
  rdfs:comment "Returns a literal of the same kind (simple literal, plain literal same language tag, xsd:string) as the first argument arg1. The lexical form of the result is the substring of the value of arg1 that proceeds in arg1 the first occurrence of the lexical form of arg2; otherwise the lexical form of the result is the empty string. If the lexical form of arg2 is the empty string, the lexical form of the result is the emprty string." ;
  rdfs:label "strafter" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-strafter> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strbefore
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The pattern to find within the input string." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "STRBEFORE" ;
  rdfs:comment "Returns a literal of the same kind (simple literal, plain literal same language tag, xsd:string) as the first argument arg1. The lexical form of the result is the substring of the value of arg1 that precedes in arg1 the first occurrence of the lexical form of arg2; otherwise the lexical form of the result is the empty string. If the lexical form of arg2 is the empty string, the lexical form of the result is the emprty string." ;
  rdfs:label "strbefore" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-strbefore> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strdt
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The lexical form of the new literal." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The datatype of the new literal." ;
    ] ;
  spin:symbol "STRDT" ;
  rdfs:comment "Constructs a literal with lexical form and type as specified by the arguments." ;
  rdfs:label "strdt" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-strdt> ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
sp:strends
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The sub-string that the input string is supposed to end with." ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "STRENDS" ;
  rdfs:comment "Returns true if the lexical form of ?arg1 ends with the lexical form of ?arg2, otherwise it returns false." ;
  rdfs:label "strends" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-ends> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strlang
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string value." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The language tag, e.g. \"en-AU\"." ;
    ] ;
  spin:returnType rdf:PlainLiteral ;
  spin:symbol "STRLANG" ;
  rdfs:comment "Takes a string (?arg1) and a language (?arg2) and constructs a literal with a corresponding language tag." ;
  rdfs:label "strlang" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-strlang> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strlen
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "STRLEN" ;
  rdfs:comment "Computes the length of a given input string." ;
  rdfs:label "strlen" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-strlen> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strstarts
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The sub-string that the input string is supposed to begin with." ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "STRSTARTS" ;
  rdfs:comment "Returns true if the lexical form of ?arg1 begins with the lexical form of ?arg2, otherwise it returns false." ;
  rdfs:label "strstarts" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-starts> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:struuid
  rdf:type spin:Function ;
  spin:returnType xsd:string ;
  spin:symbol "STRUUID" ;
  rdfs:comment "Returns a string that is the scheme specific part of UUID. That is, as a simple literal, the result of generating a UUID, converting to a simple literal and removing the initial urn:uuid:." ;
  rdfs:label "struuid" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:sub
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:symbol "-" ;
  rdfs:comment "Returns the arithmetic difference of its operands." ;
  rdfs:label "sub" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:substr
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The end index." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The start index." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "SUBSTR" ;
  rdfs:comment "Gets the sub-string of a given string. The index of the first character is 1." ;
  rdfs:label "substr" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-substr> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:timezone
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:dateTime ;
      rdfs:comment "The input time." ;
    ] ;
  spin:returnType xsd:duration ;
  spin:symbol "TIMEZONE" ;
  rdfs:comment "Returns the timezone part of ?arg1 as an xsd:dayTimeDuration. Raises an error if there is no timezone." ;
  rdfs:label "timezone" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-timezone> ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:tz
  rdf:type spin:Function ;
  spin:symbol "TZ" ;
  rdfs:comment "Returns the timezone part of ?arg1 as a simple literal. Returns the empty string if there is no timezone." ;
  rdfs:label "tz" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-tz> ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:ucase
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "UCASE" ;
  rdfs:comment "Converts a string to upper case characters." ;
  rdfs:label "UCASE" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-ucase> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:unaryMinus
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the operand" ;
    ] ;
  spin:symbol "-" ;
  rdfs:comment "Returns the operand ?arg1 with the sign reversed. If ?arg1 is positive, its negative is returned; if it is negative, its positive is returned." ;
  rdfs:label "unary minus" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:unaryPlus
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the operand" ;
    ] ;
  spin:symbol "+" ;
  rdfs:comment "Returns the operand ?arg1 with the sign unchanged. Semantically, this operation performs no operation." ;
  rdfs:label "unary plus" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:uri
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The IRI string to convert to a resource." ;
    ] ;
  spin:returnType rdfs:Resource ;
  spin:symbol "URI" ;
  rdfs:comment "Equivalent to IRI." ;
  rdfs:label "URI" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
sp:year
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The date or dateTime argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "year" ;
  rdfs:comment "Extracts the year from a date/time literal." ;
  rdfs:label "year" ;
  rdfs:subClassOf spl:DateFunctions ;
.
spin:eval
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The expression to evaluate. Should be a sp:Select, sp:Ask, a sp:Variable or an instance of a SPARQL function class, but may also be a simple RDF value." ;
    ] ;
.
spin:violatesConstraints
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The instance to check." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the constraints of." ;
    ] ;
.
<http://spinrdf.org/spl>
  rdf:type spin:LibraryOntology ;
  rdf:type owl:Ontology ;
  rdfs:comment "A collection of generally useful SPARQL functions (expressed as SPIN functions), and SPIN templates. Also provides a top-level classification of functions, and definitions of the standard SPARQL functions." ;
  rdfs:label "SPIN Standard Library" ;
  owl:imports <http://spinrdf.org/spin> ;
  owl:versionInfo "1.4.2" ;
.
spl:AllArguments
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "arg" ;
          ]
          [
            sp:varName "atClass" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "atClass" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "arg" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "atClass" ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spl:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the arguments of." ;
    ] ;
  spin:labelTemplate "All spl:Arguments of {?class}" ;
  rdfs:comment "Gets a list of all spl:Arguments declared at a given class and its superclasses." ;
  rdfs:label "All arguments" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
spl:Argument
  rdf:type spin:ConstructTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b14277 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b14277 ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b14277 ;
          ]
          [
            sp:object [
                sp:varName "label" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b14277 ;
          ]
        ) ;
      sp:where (
          (
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:isIRI ;
                  sp:arg1 spin:_this ;
                ] ;
            ]
          )
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  (
                    (
                      [
                        rdf:type sp:Filter ;
                        sp:expression [
                            rdf:type sp:or ;
                            sp:arg1 [
                                rdf:type sp:not ;
                                sp:arg1 [
                                    rdf:type sp:bound ;
                                    sp:arg1 [
                                        sp:varName "optional" ;
                                      ] ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                rdf:type sp:eq ;
                                sp:arg1 [
                                    sp:varName "optional" ;
                                  ] ;
                                sp:arg2 "false"^^xsd:boolean ;
                              ] ;
                          ] ;
                      ]
                    )
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:notExists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "value" ;
                                  ] ;
                                sp:predicate [
                                    sp:varName "predicate" ;
                                  ] ;
                                sp:subject spin:_this ;
                              ]
                            ) ;
                        ] ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:notExists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "template" ;
                                  ] ;
                                sp:predicate rdf:type ;
                                sp:subject spin:_this ;
                              ]
                              [
                                rdf:type sp:Filter ;
                                sp:expression [
                                    rdf:type spl:instanceOf ;
                                    sp:arg1 [
                                        sp:varName "template" ;
                                      ] ;
                                    sp:arg2 spl:UnionTemplate ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                  )
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:concat ;
                        sp:arg1 "Missing value for argument " ;
                        sp:arg2 [
                            rdf:type afn:localname ;
                            sp:arg1 [
                                sp:varName "predicate" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "label" ;
                      ] ;
                  ]
                )
                (
                  (
                    (
                      [
                        rdf:type sp:Filter ;
                        sp:expression [
                            rdf:type sp:bound ;
                            sp:arg1 [
                                sp:varName "valueType" ;
                              ] ;
                          ] ;
                      ]
                    )
                    [
                      sp:object [
                          sp:varName "value" ;
                        ] ;
                      sp:predicate [
                          sp:varName "predicate" ;
                        ] ;
                      sp:subject spin:_this ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:and ;
                          sp:arg1 [
                              rdf:type sp:not ;
                              sp:arg1 [
                                  rdf:type spl:instanceOf ;
                                  sp:arg1 [
                                      sp:varName "value" ;
                                    ] ;
                                  sp:arg2 [
                                      sp:varName "valueType" ;
                                    ] ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              rdf:type sp:or ;
                              sp:arg1 [
                                  rdf:type sp:ne ;
                                  sp:arg1 [
                                      sp:varName "valueType" ;
                                    ] ;
                                  sp:arg2 rdfs:Resource ;
                                ] ;
                              sp:arg2 [
                                  rdf:type sp:isLiteral ;
                                  sp:arg1 [
                                      sp:varName "value" ;
                                    ] ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:concat ;
                        sp:arg1 "Incorrect type of argument " ;
                        sp:arg2 [
                            rdf:type afn:localname ;
                            sp:arg1 [
                                sp:varName "predicate" ;
                              ] ;
                          ] ;
                        sp:arg3 " (expected: " ;
                        sp:arg4 [
                            rdf:type afn:localname ;
                            sp:arg1 [
                                sp:varName "valueType" ;
                              ] ;
                          ] ;
                        sp:arg5 ")" ;
                      ] ;
                    sp:variable [
                        sp:varName "label" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate spl:defaultValue ;
      rdfs:comment "the default value for the argument" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate spl:optional ;
      spl:valueType xsd:boolean ;
      rdfs:comment "indicates whether the argument is optional" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate spl:valueType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the value type of the argument" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate rdfs:comment ;
      spl:valueType xsd:string ;
      rdfs:comment "a comment describing the argument" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "the property holding the values of each function call" ;
    ] ;
  spin:labelTemplate "Argument {?predicate} : {?valueType}" ;
  rdfs:comment "Provides metadata about an argument of a SPIN Function or Template. Arguments wrap a given rdf:Property (predicate) and specify its value type and whether the argument is optional. When used as spin:constraint, the body of this template will verify that a non-optional value exists and that it has the specified value type. Arguments that have been declared spl:optional true become optional if the type of ?this is spl:UnionTemplate. " ;
  rdfs:label "Argument" ;
  rdfs:subClassOf spin:ConstructTemplates ;
.
spl:Attribute
  rdf:type spin:ConstructTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b70470 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b70470 ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b70470 ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:or ;
                    sp:arg1 [
                        rdf:type sp:and ;
                        sp:arg1 [
                            rdf:type sp:bound ;
                            sp:arg1 [
                                sp:varName "minCount" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:lt ;
                            sp:arg1 [
                                rdf:type spl:objectCount ;
                                sp:arg1 spin:_this ;
                                sp:arg2 [
                                    sp:varName "predicate" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                sp:varName "minCount" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:and ;
                        sp:arg1 [
                            rdf:type sp:bound ;
                            sp:arg1 [
                                sp:varName "maxCount" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:gt ;
                            sp:arg1 [
                                rdf:type spl:objectCount ;
                                sp:arg1 spin:_this ;
                                sp:arg2 [
                                    sp:varName "predicate" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                sp:varName "maxCount" ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:exists ;
                    sp:elements (
                        (
                          [
                            rdf:type sp:Filter ;
                            sp:expression [
                                rdf:type sp:bound ;
                                sp:arg1 [
                                    sp:varName "valueType" ;
                                  ] ;
                              ] ;
                          ]
                        )
                        [
                          sp:object [
                              sp:varName "value" ;
                            ] ;
                          sp:predicate [
                              sp:varName "predicate" ;
                            ] ;
                          sp:subject spin:_this ;
                        ]
                        [
                          rdf:type sp:Filter ;
                          sp:expression [
                              rdf:type sp:not ;
                              sp:arg1 [
                                  rdf:type spl:instanceOf ;
                                  sp:arg1 [
                                      sp:varName "value" ;
                                    ] ;
                                  sp:arg2 [
                                      sp:varName "valueType" ;
                                    ] ;
                                ] ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate spl:defaultValue ;
      rdfs:comment "the default value of the attribute" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate spl:maxCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "the maximum number of values permitted for the property" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate spl:minCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "the minimum number of values permitted for the property" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate spl:valueType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the type that all values of the property must have" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate rdfs:comment ;
      spl:valueType xsd:string ;
      rdfs:comment "a comment describing the meaning of this attribute" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "the RDF property holding the attribute value" ;
    ] ;
  spin:labelTemplate "Attribute {?predicate} : {?valueType} [{?minCount},{?maxCount}]" ;
  rdfs:comment """Defines an \"attribute\" of a class. Attribute definitions bundle common modeling patterns known from object-oriented languages like UML. Each attribute can have min and max cardinality, a value type and a default value. The attribute links a class with one RDF property. This template should be used as spin:constraints on a class to make sure that classes meet the expected cardinalities and valueType constraints.
If a model wants to use spl:defaultValue, then it should instantiate the spl:ConstructDefaultValues as a spin:constructor at some root class, such as rdfs:Resource.""" ;
  rdfs:label "Attribute" ;
  rdfs:subClassOf spin:ConstructTemplates ;
.
spl:BooleanFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "A collection of functions that return a boolean value (true or false)." ;
  rdfs:label "Boolean functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:ConstraintTemplate
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass for CONSTRUCT templates that create spin:ConstraintViolations and can be used as values of spin:constraint." ;
  rdfs:label "Constraint template" ;
  rdfs:subClassOf spin:ConstructTemplate ;
.
spl:ConstraintTemplates
  rdf:type spl:ConstraintTemplate ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "Abstract superclass of templates that can be used as spin:constraints. The subclasses are expected to construct spin:ConstraintViolations and use ?this to talk about the instances of the associated class." ;
  rdfs:label "Constraint templates" ;
  rdfs:subClassOf spin:ConstructTemplates ;
.
spl:ConstructDefaultValues
  rdf:type spin:ConstructTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object [
                sp:varName "defaultValue" ;
              ] ;
            sp:predicate [
                sp:varName "predicate" ;
              ] ;
            sp:subject spin:_this ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "directType" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_this ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "directType" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "attribute" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "defaultValue" ;
              ] ;
            sp:predicate spl:defaultValue ;
            sp:subject [
                sp:varName "attribute" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate spl:predicate ;
            sp:subject [
                sp:varName "attribute" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "Construct default values" ;
  rdfs:comment "This template can be attached as spin:constructor to a root class such as rdfs:Resource to ensure that SPIN processors assign default values to certain properties. Looks for any templates attached as spin:constraints to the types of ?this and then assigns their declared spl:defaultValues." ;
  rdfs:label "Construct default values" ;
  rdfs:subClassOf spin:ConstructTemplates ;
.
spl:CountPropertyConstraintTemplates
  rdf:type spl:ConstraintTemplate ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:maxCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum number of values that the property must have." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:minCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The minimum number of values that the property must have." ;
    ] ;
  rdfs:comment "Abstract superclass of property constraints that compare the number of values with either min or max count." ;
  rdfs:label "Count property constraint templates" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:DateFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "A collection of functions that operate on date/time literals." ;
  rdfs:label "Date functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:ExistencePropertyPairConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b76881 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b76881 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b76881 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b76881 ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:exists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "someValue" ;
                        ] ;
                      sp:predicate [
                          sp:varName "otherProperty" ;
                        ] ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "object" ;
                        ] ;
                      sp:predicate [
                          sp:varName "property" ;
                        ] ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "Property " ;
                sp:arg2 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg3 " must have a value because " ;
                sp:arg4 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "otherProperty" ;
                      ] ;
                  ] ;
                sp:arg5 " has" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "The property {?property} must have a value whenever {?otherProperty} has a value" ;
  rdfs:label "Existence property pair constraint" ;
  rdfs:subClassOf spl:PropertyPairConstraintTemplates ;
.
spl:InferDefaultValue
  rdf:type spin:ConstructTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object [
                sp:varName "defaultValue" ;
              ] ;
            sp:predicate [
                sp:varName "predicate" ;
              ] ;
            sp:subject spin:_this ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "anyValue" ;
                    ] ;
                  sp:predicate [
                      sp:varName "predicate" ;
                    ] ;
                  sp:subject spin:_this ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type sp:bound ;
                    sp:arg1 [
                        sp:varName "anyValue" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spl:defaultValue ;
      rdfs:comment "The default value to infer." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to infer the default value of." ;
    ] ;
  spin:labelTemplate "Default value for {?predicate}: {?defaultValue}" ;
  rdfs:comment "Can be used to infer default values for a given subject/predicate combination. This is typically assigned as spin:rule to a class. If ?this does not already have a value for a given property {?predicate}, then this will infer the value {?defaultValue}." ;
  rdfs:label "Infer default value" ;
  rdfs:subClassOf spin:ConstructTemplates ;
.
spl:LessThanOtherPropertyPairConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b96155 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b96155 ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate spin:violationValue ;
            sp:subject _:b96155 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b96155 ;
          ]
          [
            sp:object [
                sp:varName "label" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b96155 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            sp:object [
                sp:varName "otherValue" ;
              ] ;
            sp:predicate [
                sp:varName "otherProperty" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:ge ;
                sp:arg1 [
                    sp:varName "value" ;
                  ] ;
                sp:arg2 [
                    sp:varName "otherValue" ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
                sp:arg3 " of " ;
                sp:arg4 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg5 " must be less than " ;
                sp:arg6 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "otherValue" ;
                      ] ;
                  ] ;
                sp:arg7 " of " ;
                sp:arg8 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "otherProperty" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "Values of {?property} must be less than the values of {?otherProperty}" ;
  rdfs:comment "Can be used to define a constraint between two properties (?property and ?otherProperty) enforcing the invariant that the values of ?property must be smaller than the values of ?otherProperty. For example this can be used to state that ex:startDate must be < ex:endDate." ;
  rdfs:label "Less than other property pair constraint" ;
  rdfs:subClassOf spl:PropertyPairConstraintTemplates ;
.
spl:MathematicalFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "A collection of functions operating on numbers." ;
  rdfs:label "Mathematical functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:MiscFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "A collection of functions that are difficult to categorize." ;
  rdfs:label "Misc functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:NonExistencePropertyPairConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b47159 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b47159 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b47159 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b47159 ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "someValue" ;
                        ] ;
                      sp:predicate [
                          sp:varName "otherProperty" ;
                        ] ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:exists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "object" ;
                        ] ;
                      sp:predicate [
                          sp:varName "property" ;
                        ] ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "Property " ;
                sp:arg2 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg3 " must have no values because " ;
                sp:arg4 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "otherProperty" ;
                      ] ;
                  ] ;
                sp:arg5 " has none" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "The property {?property} must have no values as long as {?otherProperty} has none" ;
  rdfs:label "Non-existence property pair constraint" ;
  rdfs:subClassOf spl:PropertyPairConstraintTemplates ;
.
spl:ObjectCountPropertyConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b46843 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b46843 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b46843 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b46843 ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:objectCount ;
                sp:arg1 spin:_this ;
                sp:arg2 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectCount" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "minCount" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:lt ;
                        sp:arg1 [
                            sp:varName "objectCount" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "minCount" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "maxCount" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:gt ;
                        sp:arg1 [
                            sp:varName "objectCount" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "maxCount" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "Invalid number of values: " ;
                sp:arg2 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "objectCount" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "The property {?property} must have between {?minCount} and {?maxCount} values" ;
  rdfs:comment "Represents a constraint that can be attached to a class to specify that a given property must have between min and max values." ;
  rdfs:label "Object count property constraint" ;
  rdfs:subClassOf spl:CountPropertyConstraintTemplates ;
.
spl:OntologyFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "A collection of functions performing ontology-related operations." ;
  rdfs:label "Ontology functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:PrimaryKeyPropertyConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b83324 ;
          ]
          [
            sp:object [
                sp:varName "label" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b83324 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b83324 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b83324 ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:notExists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "any" ;
                                ] ;
                              sp:predicate [
                                  sp:varName "property" ;
                                ] ;
                              sp:subject spin:_this ;
                            ]
                          ) ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression "Missing value for primary key property" ;
                    sp:variable [
                        sp:varName "label" ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:gt ;
                        sp:arg1 [
                            rdf:type spl:objectCount ;
                            sp:arg1 spin:_this ;
                            sp:arg2 [
                                sp:varName "property" ;
                              ] ;
                          ] ;
                        sp:arg2 1 ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression "Multiple values of primary key property" ;
                    sp:variable [
                        sp:varName "label" ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:eq ;
                        sp:arg1 [
                            rdf:type spl:objectCount ;
                            sp:arg1 spin:_this ;
                            sp:arg2 [
                                sp:varName "property" ;
                              ] ;
                          ] ;
                        sp:arg2 1 ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "value" ;
                      ] ;
                    sp:predicate [
                        sp:varName "property" ;
                      ] ;
                    sp:subject spin:_this ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:concat ;
                        sp:arg1 [
                            sp:varName "uriStart" ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:encode_for_uri ;
                            sp:arg1 [
                                rdf:type xsd:string ;
                                sp:arg1 [
                                    sp:varName "value" ;
                                  ] ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "uri" ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:ne ;
                        sp:arg1 [
                            rdf:type xsd:string ;
                            sp:arg1 spin:_this ;
                          ] ;
                        sp:arg2 [
                            sp:varName "uri" ;
                          ] ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:concat ;
                        sp:arg1 "Primary key value " ;
                        sp:arg2 [
                            rdf:type sp:str ;
                            sp:arg1 [
                                sp:varName "value" ;
                              ] ;
                          ] ;
                        sp:arg3 " does not align with the expected URI " ;
                        sp:arg4 [
                            sp:varName "uri" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "label" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object rdfs:label ;
            sp:predicate arg:property ;
            sp:subject spin:_this ;
          ]
        ) ;
      rdfs:comment "rdfs:label cannot be used as primary key" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uriStart ;
      spl:valueType xsd:string ;
      rdfs:comment "The start of the URIs of well-formed instances of the associated class." ;
    ] ;
  spin:labelTemplate "The property {?property} is the primary key and URIs start with {?uriStart}" ;
  rdfs:comment "Specifies that the given property is a primary key for instances of the associated class (and its subclasses). If a property has been declared to be the primary key then each instance of the class must have exactly one value for that property. Furthermore, the URIs of those instances must start with a given string (arg:uriStart), followed by the URL-encoded primary key value. For example if arg:uriStart is \"http://example.org/country-\" and the primary key for an instance is \"de\" then the URI must be \"http://example.org/country-de\". Finally, as a result of the URI policy, there can not be any other instance with the same value under the same primary key policy." ;
  rdfs:label "Primary key property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:PropertyConstraintTemplates
  rdf:type spl:ConstraintTemplate ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property being constrained." ;
    ] ;
  rdfs:comment "Abstract superclass of constraint templates that constrain exactly one property." ;
  rdfs:label "Property constraint templates" ;
  rdfs:subClassOf spl:ConstraintTemplates ;
.
spl:PropertyPairConstraintTemplates
  rdf:type spl:ConstraintTemplate ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:otherProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The \"other\" property." ;
    ] ;
  rdfs:comment "Abstract base class for templates that take two properties as arguments and establish a relationship between them." ;
  rdfs:label "Property pair constraint templates" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:RangePropertyConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b28065 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b28065 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b28065 ;
          ]
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate spin:violationValue ;
            sp:subject _:b28065 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b28065 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "min" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:lt ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "min" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "max" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:gt ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "max" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 " must be in the interval [" ;
                sp:arg4 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "min" ;
                      ] ;
                  ] ;
                sp:arg5 ", " ;
                sp:arg6 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "max" ;
                      ] ;
                  ] ;
                sp:arg7 "]" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:max ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The maximum value." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:min ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The minimum value." ;
    ] ;
  spin:labelTemplate "Values of {?property} must be within the interval [ {?min} , {?max} ]" ;
  rdfs:comment "Represents a constraint that narrows down a property by a minimum and maximum value compared by <= and >=." ;
  rdfs:label "Range property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:RegexPropertyConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b11396 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b11396 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b11396 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b11396 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type sp:regex ;
                    sp:arg1 [
                        rdf:type xsd:string ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        sp:varName "pattern" ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 " must match the regular expression \"" ;
                sp:arg4 [
                    sp:varName "pattern" ;
                  ] ;
                sp:arg5 "\"" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:pattern ;
      spl:valueType xsd:string ;
      rdfs:comment "The regular expression to match." ;
    ] ;
  spin:labelTemplate "Values of {?property} must match the regular expression {?pattern}" ;
  rdfs:label "Regex property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:RunTestCases
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "testCase" ;
          ]
          [
            sp:varName "expected" ;
          ]
          [
            sp:varName "actual" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "expr" ;
              ] ;
            sp:predicate spl:testExpression ;
            sp:subject [
                sp:varName "testCase" ;
              ] ;
          ]
          [
            rdf:type sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "expected" ;
                    ] ;
                  sp:predicate spl:testResult ;
                  sp:subject [
                      sp:varName "testCase" ;
                    ] ;
                ]
              ) ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spin:eval ;
                sp:arg1 [
                    sp:varName "expr" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "actual" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:ne ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "expected" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "actual" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "expected" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:ne ;
                        sp:arg1 [
                            sp:varName "actual" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "expected" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Runs all spl:TestCases on the current model." ;
  rdfs:label "Run test cases" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
spl:SPINOverview
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "class" ;
          ]
          [
            sp:varName "property" ;
          ]
          [
            sp:varName "rule" ;
          ]
        ) ;
      sp:where (
          (
            [
              rdf:type sp:Union ;
              sp:elements (
                  (
                    [
                      rdf:type sp:Bind ;
                      sp:expression spin:constraint ;
                      sp:variable [
                          sp:varName "bp" ;
                        ] ;
                    ]
                  )
                  (
                    [
                      rdf:type sp:Bind ;
                      sp:expression spin:constructor ;
                      sp:variable [
                          sp:varName "bp" ;
                        ] ;
                    ]
                  )
                  (
                    [
                      rdf:type sp:Bind ;
                      sp:expression spin:rule ;
                      sp:variable [
                          sp:varName "bp" ;
                        ] ;
                    ]
                  )
                ) ;
            ]
          )
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "bp" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "rule" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:ne ;
                sp:arg1 [
                    sp:varName "class" ;
                  ] ;
                sp:arg2 spin:Modules ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object spl:Argument ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "rule" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object spl:Attribute ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "rule" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "SPIN Overview" ;
  rdfs:comment "Finds all constraints and rules attached to classes in the current graph, using spin:constraint, spin:constructor, spin:rule or their sub-properties. The result set will contain the associated class, the predicate, and the SPIN rule." ;
  rdfs:label "SPIN Overview" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
spl:StringFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "A collection of functions that return strings." ;
  rdfs:label "String functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:StringLengthPropertyConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b54635 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b54635 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b54635 ;
          ]
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate spin:violationValue ;
            sp:subject _:b54635 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b54635 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:strlen ;
                sp:arg1 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "length" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:lt ;
                    sp:arg1 [
                        sp:varName "length" ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:coalesce ;
                        sp:arg1 [
                            sp:varName "minLength" ;
                          ] ;
                        sp:arg2 0 ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "maxLength" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:gt ;
                        sp:arg1 [
                            sp:varName "length" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "maxLength" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 " must have between " ;
                sp:arg4 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "minLength" ;
                      ] ;
                  ] ;
                sp:arg5 " and " ;
                sp:arg6 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "maxLength" ;
                      ] ;
                  ] ;
                sp:arg7 " characters" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:maxLength ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum number of characters (defaults to unlimited)." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:minLength ;
      spl:valueType xsd:integer ;
      rdfs:comment "The minimum number of characters (default to 0)." ;
    ] ;
  spin:labelTemplate "Values of {?property} must have between {?minLength} and {?maxLength} characters" ;
  rdfs:comment "Represents a constraint that narrows down a property by a minimum and maximum length of the characters of the string representation of its values. This constraint is typically used for string literals, but may also be useful for integers (e.g. 4 digit numbers), and may even be used to limit the length of URIs." ;
  rdfs:label "String length property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:Test-instanceOf-lingualString
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spl:instanceOf ;
      sp:arg1 "test"@en ;
      sp:arg2 xsd:string ;
    ] ;
  spl:testResult "true"^^xsd:boolean ;
.
spl:Test-instanceOf-rdfsClass
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spl:instanceOf ;
      sp:arg1 owl:Thing ;
      sp:arg2 rdfs:Class ;
    ] ;
  spl:testResult "true"^^xsd:boolean ;
.
spl:Test-instanceOf-rdfsClass-false
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spl:instanceOf ;
      sp:arg1 owl:versionInfo ;
      sp:arg2 rdfs:Class ;
    ] ;
  spl:testResult "false"^^xsd:boolean ;
.
spl:Test-instanceOf-rdfsClassInheritance
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spl:instanceOf ;
      sp:arg1 owl:Restriction ;
      sp:arg2 rdfs:Class ;
    ] ;
  spl:testResult "true"^^xsd:boolean ;
.
spl:Test-instanceOf-rdfsLiteral
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spl:instanceOf ;
      sp:arg1 "test" ;
      sp:arg2 rdfs:Literal ;
    ] ;
  spl:testResult "true"^^xsd:boolean ;
.
spl:Test-instanceOf-rdfsLiteral-false
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spl:instanceOf ;
      sp:arg1 owl:Thing ;
      sp:arg2 rdfs:Literal ;
    ] ;
  spl:testResult "false"^^xsd:boolean ;
.
spl:Test-instanceOf-typedString
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spl:instanceOf ;
      sp:arg1 "test" ;
      sp:arg2 xsd:string ;
    ] ;
  spl:testResult "true"^^xsd:boolean ;
.
spl:Test-instanceOf-typedString-false
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spl:instanceOf ;
      sp:arg1 "test" ;
      sp:arg2 xsd:integer ;
    ] ;
  spl:testResult "false"^^xsd:boolean ;
.
spl:Test-instanceOf-untypedString
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spl:instanceOf ;
      sp:arg1 "test" ;
      sp:arg2 xsd:string ;
    ] ;
  spl:testResult "true"^^xsd:boolean ;
.
spl:Test-object-labelOfArgument
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spl:object ;
                      sp:arg1 spl:Argument ;
                      sp:arg2 rdfs:label ;
                    ] ;
                  sp:variable [
                      sp:varName "value" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode <http://spinrdf.org/spl> ;
          ]
        ) ;
    ] ;
  spl:testResult "Argument" ;
.
spl:Test-object-noValue
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spl:object ;
      sp:arg1 owl:versionInfo ;
      sp:arg2 owl:versionInfo ;
    ] ;
.
spl:TestCase
  rdf:type rdfs:Class ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate spl:testResult ;
      rdfs:comment "The expected result of the test case, or nothing to indicate that an error is expected." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spl:testExpression ;
      rdfs:comment "The test expression or SELECT query (anything that can be evaluated with spin:eval)." ;
    ] ;
  rdfs:comment "A test to verify that a SPIN function or magic property works as expected, and to generate documentation of example uses of the function. Each TestCase consists of a SPARQL function call or an expression that can be executed with spin:eval, and an expected result. The test framework only needs to execute spin:eval on the expression and compare it with the expected result." ;
  rdfs:label "Test case" ;
  rdfs:subClassOf rdfs:Resource ;
.
spl:TypePropertyConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b52205 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b52205 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b52205 ;
          ]
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate spin:violationValue ;
            sp:subject _:b52205 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b52205 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type spl:instanceOf ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "type" ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 " must have the type " ;
                sp:arg4 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "type" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that the values must have as their rdf:type (or a subclass thereof)." ;
    ] ;
  spin:labelTemplate "Values of {?property} must have the type {?type}" ;
  rdfs:comment "Represents a constraint that narrows down the rdf:type of the values of a property." ;
  rdfs:label "Type property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:URIFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment "A collection of functions that create URI resources." ;
  rdfs:label "URI functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:UnionTemplate
  rdf:type rdfs:Class ;
  rdfs:comment "This type can be used for templates that serve as the union (or \"collector\") of other templates. Union templates differ from other templates in that all spl:Arguments are optional. This means that union templates can be declared as subclasses of multiple other templates, yet when instantiated, only some of the arguments defined by the superclasses need to be filled in." ;
  rdfs:label "Union template" ;
  rdfs:subClassOf spin:Template ;
.
spl:UniquePropertyValueConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b40220 ;
          ]
          [
            sp:object [
                sp:varName "label" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b40220 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b40220 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b40220 ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate spin:violationValue ;
            sp:subject _:b40220 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:exists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "value" ;
                        ] ;
                      sp:predicate [
                          sp:varName "property" ;
                        ] ;
                      sp:subject [
                          sp:varName "other" ;
                        ] ;
                    ]
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:ne ;
                          sp:arg1 spin:_this ;
                          sp:arg2 [
                              sp:varName "other" ;
                            ] ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "Property must have a unique value, but " ;
                sp:arg2 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
                sp:arg3 "  already exists elsewhere. " ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "Values of {?property} must be unique" ;
  rdfs:comment "Reports an error if the given property has a value that is also used elsewhere, for the same property." ;
  rdfs:label "Unique property value constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:UntypedObjectPropertyConstraint
  rdf:type spl:ConstraintTemplate ;
  spin:body [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b30331 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b30331 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b30331 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b30331 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "anyType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "object" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    rdf:type sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 " must have a type" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "Values of {?property} must have a type" ;
  rdfs:comment "A generic SPIN template that can be used to declare a constraint that all values of a given property must have an rdf:type." ;
  rdfs:label "Untyped object property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:class
  rdf:type rdf:Property ;
  rdfs:label "class" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:count
  rdf:type rdf:Property ;
  rdfs:label "count" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:defaultValue
  rdf:type rdf:Property ;
  rdfs:label "default value" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:hasArgument
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "superClass" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "con" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "con" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spl:class ;
      spl:valueType spin:Module ;
      rdfs:comment "The module class to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given module class (?module) has at least one declared spl:Argument." ;
  rdfs:label "has argument" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
spl:hasPrimaryKey
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:primaryKeyProperty ;
                arg:class [
                    sp:varName "class" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "primaryKey" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "primaryKey" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given class has a declared primary key, using spl:PrimaryKeyPropertyConstraint." ;
  rdfs:label "has primary key" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:hasValue
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object spin:_arg2 ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject [
                sp:varName "p" ;
              ] ;
          ]
          [
            sp:object spin:_arg3 ;
            sp:predicate [
                sp:varName "p" ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the subject that is expected to have the value" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the property that is expected to hold the value" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "the expected value" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource (?arg1) has a given value (?arg3) for a given property (?arg2) or one of the sub-properties of it." ;
  rdfs:label "hasValue" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
spl:hasValueOfType
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object spin:_arg2 ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject [
                sp:varName "p" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "p" ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type spl:instanceOf ;
                sp:arg1 [
                    sp:varName "value" ;
                  ] ;
                sp:arg2 spin:_arg3 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the subject that is expected to have the value" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the expected property" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the type to match against" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given subject (?arg1) has at least one value of a given type (?arg3) for a given property (?arg2) or one of its sub-properties." ;
  rdfs:label "hasValueOfType" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
spl:instance
  rdf:type rdf:Property ;
  rdfs:domain sp:ModuleCall ;
  rdfs:label "instance" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:instanceOf
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  (
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:or ;
                          sp:arg1 [
                              rdf:type sp:isIRI ;
                              sp:arg1 spin:_arg1 ;
                            ] ;
                          sp:arg2 [
                              rdf:type sp:isBlank ;
                              sp:arg1 spin:_arg1 ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    rdf:type sp:TriplePath ;
                    sp:object spin:_arg2 ;
                    sp:path [
                        rdf:type sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "class" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  (
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:isLiteral ;
                          sp:arg1 spin:_arg1 ;
                        ] ;
                    ]
                  )
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:datatype ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                    sp:variable [
                        sp:varName "datatype" ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:or ;
                        sp:arg1 [
                            rdf:type sp:or ;
                            sp:arg1 [
                                rdf:type sp:eq ;
                                sp:arg1 [
                                    sp:varName "datatype" ;
                                  ] ;
                                sp:arg2 spin:_arg2 ;
                              ] ;
                            sp:arg2 [
                                rdf:type sp:eq ;
                                sp:arg1 spin:_arg2 ;
                                sp:arg2 rdfs:Literal ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:and ;
                            sp:arg1 [
                                rdf:type sp:or ;
                                sp:arg1 [
                                    rdf:type sp:not ;
                                    sp:arg1 [
                                        rdf:type sp:bound ;
                                        sp:arg1 [
                                            sp:varName "datatype" ;
                                          ] ;
                                      ] ;
                                  ] ;
                                sp:arg2 [
                                    rdf:type sp:eq ;
                                    sp:arg1 rdf:langString ;
                                    sp:arg2 [
                                        sp:varName "datatype" ;
                                      ] ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                rdf:type sp:eq ;
                                sp:arg1 spin:_arg2 ;
                                sp:arg2 xsd:string ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the instance being tested" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the type that the instance must have" ;
    ] ;
  spin:labelTemplate "{?arg1} instance of {?arg2}" ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource (?arg1) has a given type (?arg2). In order to fulfill this condition, there must either be a triple ?arg1 rdf:type ?arg2, or ?instance rdf:type ?subClass where ?subClass is a subclass of ?arg2. If the first argument is a literal, then the second argument must be the matching XSD datatype." ;
  rdfs:label "instanceOf" ;
  rdfs:subClassOf spl:BooleanFunctions ;
  owl:versionInfo "Note that in TopBraid this function has been implemented in native Java code, for performance reasons." ;
.
spl:isPrimaryKeyPropertyOfInstance
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "instance" ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:primaryKeyProperty ;
                arg:class [
                    sp:varName "type" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "pk" ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
                sp:arg2 [
                    sp:varName "pk" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:instance ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The instance to check." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property that may or may not be the primary key." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given property is the primary key of a given instance." ;
  rdfs:label "is primary key property of instance" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:isUntypedLiteral
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:and ;
                sp:arg1 [
                    rdf:type sp:isLiteral ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:sameTerm ;
                        sp:arg1 spin:_arg1 ;
                        sp:arg2 [
                            rdf:type xsd:string ;
                            sp:arg1 spin:_arg1 ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The literal to test." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given literal is untyped. This function was introduced because the built-in datatype operand in SPARQL casts untyped literals to xsd:string, making it impossible to check it this way. This function here uses a work-around using sameTerm instead." ;
  rdfs:label "isUntypedLiteral" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
spl:max
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:gt ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 spin:_arg2 ;
                  ] ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The first argument." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The second argument." ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment "Takes two arguments and returns the larger one of them." ;
  rdfs:label "max" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
spl:maxCount
  rdf:type rdf:Property ;
  rdfs:subPropertyOf spl:count ;
.
spl:min
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:lt ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 spin:_arg2 ;
                  ] ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The first argument." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The second argument." ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment "Takes two arguments and returns the smaller one of them." ;
  rdfs:label "min" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
spl:minCount
  rdf:type rdf:Property ;
  rdfs:subPropertyOf spl:count ;
.
spl:object
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate spin:_arg2 ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the object from." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the object of." ;
    ] ;
  rdfs:comment """Gets the object of a given subject (?arg1) / predicate (?arg2) combination.

Note that if multiple values are present then the result might be unpredictably random. Furthermore, if one of the arguments is unbound, it will return the first match of the resulting SPO pattern. These scenarios are strongly discouraged but remain left supported for backward compatibility reasons.""" ;
  rdfs:label "object" ;
  rdfs:subClassOf spl:OntologyFunctions ;
  owl:versionInfo "Note that in TopBraid this function has been implemented in native Java code, for performance reasons." ;
.
spl:objectCount
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Count ;
                sp:expression [
                    sp:varName "object" ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate spin:_arg2 ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the subject to get the number of objects of" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the property to get the number of values of" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the number of values of a given property (?arg2) at a given subject (?arg1). The result is the number of matches of (?arg1, ?arg2, ?object)." ;
  rdfs:label "objectCount" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:objectInGraph
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "object" ;
                    ] ;
                  sp:predicate spin:_arg2 ;
                  sp:subject spin:_arg1 ;
                ]
              ) ;
            sp:graphNameNode spin:_arg3 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the object from." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the object of." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to query in." ;
    ] ;
  rdfs:comment "Gets the object of a given subject (?arg1) / predicate (?arg2) combination in a given graph ?arg3. Note that if multiple values are present then the result might be unpredictably random." ;
  rdfs:label "object in graph" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:objectSubProp
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object spin:_arg2 ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the object from." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the object of (including sub-properties of it)." ;
    ] ;
  rdfs:comment "Gets the object of a given subject (?arg1) / predicate (?arg2) combination, also taking the sub-properties of ?arg2 into account. Note that if multiple values are present then the result might be unpredictably random." ;
  rdfs:label "object sub prop" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:optional
  rdf:type rdf:Property ;
  rdfs:label "optional" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf sp:arg ;
.
spl:predicate
  rdf:type rdf:Property ;
  rdfs:label "predicate" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:primaryKeyProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "constraint" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object spl:PrimaryKeyPropertyConstraint ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate arg:property ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets the primary key property declared for a given class, using spl:PrimaryKeyPropertyConstraint." ;
  rdfs:label "primary key property" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:primaryKeyURIStart
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "constraint" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object spl:PrimaryKeyPropertyConstraint ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "result" ;
              ] ;
            sp:predicate arg:uriStart ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets the URI start declared as part of a primary key declaration for a given class, using spl:PrimaryKeyPropertyConstraint." ;
  rdfs:label "primary key URI start" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:relevantPropertyAtClass
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:resultVariables (
          [
            sp:varName "class" ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "superClass" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "superClass" ;
                      ] ;
                    sp:predicate rdfs:domain ;
                    sp:subject [
                        sp:varName "property" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate owl:onProperty ;
                    sp:subject [
                        sp:varName "superClass" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "superClass" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "listSegment" ;
                      ] ;
                  ]
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "listSegment" ;
                      ] ;
                    sp:path [
                        rdf:type sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdf:rest ;
                      ] ;
                    sp:subject [
                        sp:varName "list" ;
                      ] ;
                  ]
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "list" ;
                      ] ;
                    sp:path [
                        rdf:type sp:SeqPath ;
                        sp:path1 rdfs:domain ;
                        sp:path2 owl:unionOf ;
                      ] ;
                    sp:subject [
                        sp:varName "property" ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:eq ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:notExists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "anyDomain" ;
                            ] ;
                          sp:predicate rdfs:domain ;
                          sp:subject spin:_arg1 ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:isIRI ;
                sp:arg1 [
                    sp:varName "class" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property." ;
    ] ;
  spin:returnType rdfs:Class ;
  rdfs:comment """A magic property that establishes a relationship between properties (left) and classes (right) to determine which properties are \"relevant\" for the class. Relevant means that they have the class in their domain and/or restrictions, including superclasses and sub-properties (unless they define their own domain). Domains consisting of an owl:unionOf are also handled.

Note that the performance of the body of this magic property has been optimized for the case in which the class is given, so ideally use this for queries such as  ?property spl:relevantPropertyAtClass skos:Concept .""" ;
  rdfs:label "relevant property at class" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spl:subClassOf
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object spin:_arg2 ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The potential sub-class." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The potential super-class." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given class (?arg1) is a (transitive) sub-class of another class (?arg2)." ;
  rdfs:label "sub class of" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:subPropertyOf
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object spin:_arg2 ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The potential sub-property." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The potential super-property." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property (?arg1) is a (transitive) sub-property of another property (?arg2)." ;
  rdfs:label "sub property of" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:subject
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "subject" ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg2 ;
            sp:predicate spin:_arg1 ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The object." ;
    ] ;
  rdfs:comment "Gets the \"first\" subject of a given predicate (?arg1)/object (?arg2) combination. Note that if multiple values are present then the result might be unpredictably random." ;
  rdfs:label "subject" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:subjectCount
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:Count ;
                sp:expression [
                    sp:varName "subject" ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg2 ;
            sp:predicate spin:_arg1 ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the predicate to get the number of subjects of" ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "the object to get the number of subjects of" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the number of values of a given property (?arg1) at a given object (?arg2). The result is the number of matches of (?subject, ?arg1, ?arg2)." ;
  rdfs:label "subjectCount" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:testExpression
  rdf:type rdf:Property ;
  rdfs:label "test expression" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:testResult
  rdf:type rdf:Property ;
  rdfs:label "testResult" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:valueType
  rdf:type rdf:Property ;
  rdfs:label "value type" ;
  rdfs:subPropertyOf sp:arg ;
.
